# Отчёт по 5 стейджу.

К сожалению, так как 4 стейдж я не делал, сравнений не будет, 
так как по сравнению с 3 серьёзные изменения в структуре.

Также были изменены [скрипты](../scripts) в связи с добавлением
параметров `ack = 2 и from = 3`, а также в скрипты была добавлена 
рандомизацией кластера.

## wrk

[пример](../report5/wrk/put)
Тестил на 4 тредах и 16 коннекшенах. Точка разладки `12500`, 
соответственно тестим на 10000. Стоит отметить стабильную
работу с многопоточкой, и получается заметное улучшение по скорости
относительнно первых стейджей.

## asyncprof

### cpu

[put cpu](../report5/asyncprof/put_cpu_prof.html)
[get cpu](../report5/asyncprof/get_cpu_prof.html)

Сразу стоит отметить значительное изменение
распределие ресурсов процессора. <br>
Так `remote` занимает всего около 15% ресурсов процессора, так же как и
обработка таски `completableFeature` и обработка её завершения 
в то время как почти вся остальная часть ресурсов уходит на скедулер и пакет
`jdk/internal/net`

### alloc

[put alloc](../report5/asyncprof/put_alloc_prof.html)
[get alloc](../report5/asyncprof/get_alloc_prof.html)

Примерно 30 процентов приходится на всё тот же скедулер,
а аллокации непосредственно обработки запроса (50%) связаны
с хэдерами запросов, примерно 20%. Остальное это аллокации связанные с `CompletableFeature`,
локальными переменными и получением результата.

### lock 

[put lock](../report5/asyncprof/put_lock_prof.html)
[get lock](../report5/asyncprof/get_lock_prof.html)

С точки зрения локов картина довольно простая `CompletableFuture`
забирают примерно 80%, что вполне логично.

